# 2006년 3월

Clojure 프로젝트의 시작. Rich Hickey가 IntelliJ IDEA에서 프로젝트를 생성하고 런타임 기초 코드를 작성.

- **커밋 수:** 22개
- **탐색 완료:** 12 / 22

---

## 커밋 #1
- **Hash:** `e54a1ff1ac0d02560e80aad460e77ac353efad49`
- **Date:** 2006-03-24
- **Message:** "created IDEA project"

### 변경 파일

| 파일 | 변경 |
|------|------|
| CPL.TXT | +94 (Common Public License 라이선스) |
| clojure.iml | +19 (IntelliJ IDEA 프로젝트 설정) |

### 메모
Rich Hickey가 IntelliJ IDEA에서 Clojure 프로젝트를 처음 시작한 커밋.
아직 실제 코드는 없고 프로젝트 설정 파일만 존재.

---

## 커밋 #2
- **Hash:** `894a0c81075b8f4b64b7f890ab0c8522a7a9986a`
- **Date:** 2006-03-25
- **Message:** "baseline versions"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/Cons.java | +26 |
| src/org/clojure/runtime/Symbol.java | +16 |
| src/org/clojure/runtime/ThreadLocalData.java | +72 |

### 메모
**Clojure 런타임의 첫 코드!** 핵심 데이터 구조 3개가 등장:

1. **Cons** - Lisp의 기본 데이터 구조. `first`와 `rest`로 구성된 연결 리스트 노드.
   ```java
   public Object first;
   public Cons rest;
   ```

2. **Symbol** - 아직 빈 클래스. 심볼을 위한 플레이스홀더.

3. **ThreadLocalData** - 동적 바인딩(dynamic binding) 관리. Clojure의 `dynamic vars` 기능의 기초.
   - `IdentityHashMap`으로 심볼별 바인딩 스택 관리
   - `pushDynamicBinding` / `popDynamicBinding`으로 스택 조작
   - `InheritableThreadLocal`로 자식 스레드에 바인딩 상속

첫날(3/24)에 프로젝트 설정, 다음날(3/25)에 바로 핵심 런타임 코드 시작.

---

## 커밋 #3
- **Hash:** `d0aa19b1da4d796b3638c1dc8a43a314b9f62ff0`
- **Date:** 2006-03-25 (같은 날 약 3시간 후)
- **Message:** "added AMap"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/AMap.java | +35 (신규) |
| src/org/clojure/runtime/IFn.java | +34 (신규) |
| src/org/clojure/runtime/Cons.java | +1/-1 |
| src/org/clojure/runtime/Symbol.java | +1/-1 |

### 메모
**IFn 인터페이스 등장!** Clojure의 모든 함수가 구현하는 핵심 인터페이스.

1. **IFn** - 함수 호출 인터페이스
   ```java
   public Object invoke(ThreadLocalData tld) throws Exception;
   public Object invoke(ThreadLocalData tld, Object arg1) throws Exception;
   public Object invoke(ThreadLocalData tld, Object arg1, Object arg2) throws Exception;
   // ... 최대 5개 인자 + 나머지는 Cons로
   public Object applyTo(ThreadLocalData tld, Cons arglist) throws Exception;
   ```
   - 인자 개수별 오버로드 (0~5개)
   - 6개 이상은 `Cons` 리스트로 전달
   - 모든 호출에 `ThreadLocalData` 전달 (동적 바인딩 접근용)

2. **AMap** - 속성 맵 (Attribute Map)
   - `IdentityHashMap` 기반
   - Symbol을 키로 사용
   - 지연 초기화 (`attrs == null`이면 생성)

---

## 커밋 #4
- **Hash:** `2081b7e8bbffe24ffa422dfd84262ff35e2aaa35`
- **Date:** 2006-03-25 (같은 날 약 1시간 후)
- **Message:** "added AFn, RT"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/AFn.java | +98 (신규) |
| src/org/clojure/runtime/RT.java | +96 (신규) |

### 메모
**핵심 런타임 클래스 2개 추가!**

1. **AFn** (Abstract Function) - IFn의 기본 구현
   - `AMap`을 상속하고 `IFn`을 구현
   - 모든 `invoke()` 메서드가 기본적으로 `throwArity()` 호출 (잘못된 인자 수 에러)
   - `applyTo()` - 리스트를 받아 적절한 `invoke()`로 디스패치
   ```java
   switch(RT.boundedLength(arglist, 5)) {
       case 0: return invoke(tld);
       case 1: return invoke(tld, arglist.first);
       // ...
   }
   ```
   - 함수가 `AMap`을 상속 → 함수도 메타데이터(속성)를 가질 수 있음!

2. **RT** (Runtime) - 런타임 유틸리티
   - `cons(x, y)` - Cons 셀 생성
   - `list(...)` - 리스트 생성 (0~5개 인자)
   - `listStar(...)` - Common Lisp의 `list*` (마지막이 rest)
   - `length()` / `boundedLength()` - 리스트 길이 계산

**설계 포인트:**
- 인자 개수별 오버로드로 박싱/언박싱 오버헤드 최소화
- `boundedLength`로 무한 리스트 방지

---

## 커밋 #5
- **Hash:** `428aa9c52d4cd274b0cfa3097e9661d76a7ea884`
- **Date:** 2006-03-27 (월요일, 주말 지나고)
- **Message:** "added return value to put()"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/AMap.java | +2/-1 |

### 메모
작은 리팩토링. `AMap.put()`이 값을 반환하도록 변경:

```java
// Before
public void put(Symbol key, Object val)

// After
public Object put(Symbol key, Object val) {
    // ...
    return val;
}
```

이렇게 하면 `map.put(k, v)`의 결과를 바로 사용할 수 있음 (메서드 체이닝, 표현식으로 사용 등).

---

## 커밋 #6
- **Hash:** `f4f532eecf07fb55ba43a4fb5258b09a32a6bc3d`
- **Date:** 2006-03-27 (커밋 #5와 같은 날, 8분 후)
- **Message:** "implemented IFn for attr access"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/Symbol.java | +28/-1 |

### 메모
**Symbol이 함수가 되었다!** `Symbol extends AFn`으로 변경.

```java
// 1인자: getter
public Object invoke(ThreadLocalData tld, Object obj) {
    return ((AMap)obj).get(this);
}

// 2인자: setter
public Object invoke(ThreadLocalData tld, Object obj, Object val) {
    return ((AMap)obj).put(this, val);
}
```

**Clojure에서 이렇게 사용:**
```clojure
;; 키워드/심볼을 함수처럼 호출
(:name person)        ; → (name person) = person.get(:name)
(:name person "default")  ; 2인자 버전은 setter? (나중에 변경됨)
```

**설계 포인트:**
- "모든 것이 함수" 철학의 시작
- 심볼/키워드가 맵에서 값을 꺼내는 함수로 동작
- `Symbol extends AFn extends AMap implements IFn`

---

## 커밋 #7
- **Hash:** `60d5204f86972c94429009b7e97f554ba8c49f36`
- **Date:** 2006-03-27 (같은 날 저녁)
- **Message:** "first-cut implementation"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/Namespace.java | +61 (신규) |
| src/org/clojure/runtime/Symbol.java | +42 |

### 메모
**Namespace와 Symbol 값 바인딩 등장!** Var 시스템의 초기 형태.

#### Namespace
```java
static final HashMap table;     // 전역: String → Namespace
final HashMap symbols;          // 로컬: String → Symbol
final String name;

static Namespace findOrCreate(String name)  // 네임스페이스 검색/생성
public Symbol intern(String name)           // 심볼 인터닝 (같은 이름 = 같은 객체)
```

#### Symbol 확장
```java
public final String name;           // 심볼 이름
public final Namespace namespace;   // 소속 네임스페이스
public Object val = UNBOUND;        // 전역 값
public IFn fn;                      // 값이 함수면 여기에도 저장

public Object getValue(ThreadLocalData tld) {
    // 1. 동적 바인딩 먼저 확인
    Cons binding = tld.getDynamicBinding(this);
    if(binding != null) return binding.first;
    // 2. 없으면 전역 값
    if(val == UNBOUND) throw new Exception(name + " is unbound.");
    return val;
}
```

**핵심 개념:**
- **인터닝 (Interning)**: 같은 이름의 심볼은 항상 같은 객체 → `==`로 비교 가능
- **값 검색 순서**: 동적 바인딩 → 전역 값
- **UNBOUND**: 아직 값이 할당되지 않은 상태

이것이 나중에 **Var**로 발전합니다.

---

## 커밋 #8
- **Hash:** `28c9cecb7ce4ad5945ae749e8e6356b3fa3f69a9`
- **Date:** 2006-03-28 (새벽 1시!)
- **Message:** "added RestFns"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/RestFn0.java | +60 (신규) |
| src/org/clojure/runtime/RestFn1.java | +59 (신규) |
| src/org/clojure/runtime/RestFn2.java | +56 (신규) |
| src/org/clojure/runtime/RestFn3.java | +52 (신규) |
| src/org/clojure/runtime/RestFn4.java | +49 (신규) |
| src/org/clojure/runtime/RestFn5.java | +45 (신규) |

### 메모
**가변 인자 함수 지원!** `& rest` 문법의 기초.

```clojure
;; Clojure에서 이렇게 사용
(fn [a b & rest] ...)  ; → RestFn2 사용
```

#### RestFn{N} 패턴
- **RestFn0**: 0개 필수 + rest
- **RestFn1**: 1개 필수 + rest
- **RestFn2**: 2개 필수 + rest
- ... **RestFn5**: 5개 필수 + rest

```java
// RestFn2 예시
protected abstract Object doInvoke(ThreadLocalData tld,
    Object arg1, Object arg2, Cons rest);

// 2개 인자로 호출 → rest = null
invoke(tld, arg1, arg2) → doInvoke(tld, arg1, arg2, null)

// 3개 인자로 호출 → rest = (arg3)
invoke(tld, arg1, arg2, arg3) → doInvoke(tld, arg1, arg2, list(arg3))

// 5개 이상 → rest에 나머지 전부
invoke(tld, a1, a2, a3, a4, a5, args) → doInvoke(tld, a1, a2, listStar(a3,a4,a5,args))
```

**설계 포인트:**
- 필수 인자 개수별로 클래스 분리 → 성능 최적화
- 나머지 인자는 Cons 리스트로 전달

---

## 커밋 #9
- **Hash:** `744751ff08b5cc68e91200b4e8b741f7d7f34cdf`
- **Date:** 2006-03-28 (새벽 1:40, 커밋 #8 후 11분)
- **Message:** "added Box"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/Box.java | +23 (신규) |

### 메모
**단순한 값 컨테이너.**

```java
public class Box {
    public Object val;

    public Box(Object val) {
        this.val = val;
    }
}
```

**용도:**
- 변경 가능한 참조가 필요할 때 (Java에서 final 변수만 클로저에서 캡처 가능)
- 메서드에서 여러 값을 반환할 때 (out parameter처럼)
- 컴파일러 내부에서 임시 저장소로 사용

23줄짜리 작은 유틸리티 클래스.

---

## 커밋 #10
- **Hash:** `578fb77842cedd3a294daaa33e411d0bb349b6d7`
- **Date:** 2006-03-28 오후 (새벽 작업 후 낮에 다시)
- **Message:** "added setValues"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/RT.java | +77 |

### 메모
**Common Lisp의 Multiple Values 구현!**

```java
static public Object setValues(ThreadLocalData tld, Object arg1, Object arg2) {
    tld.mvCount = 2;
    tld.mvArray[0] = arg1;
    tld.mvArray[1] = arg2;
    return arg1;  // 첫 번째 값만 반환
}
```

**Common Lisp에서:**
```lisp
(values 1 2 3)           ; 세 개의 값 반환
(multiple-value-bind (a b c) (values 1 2 3)
  (+ a b c))             ; → 6
```

**구현 방식:**
- `ThreadLocalData.mvArray`에 값들 저장 (최대 20개, `MULTIPLE_VALUES_LIMIT`)
- `mvCount`로 몇 개의 값이 있는지 기록
- 반환값은 첫 번째 값만 (일반적인 함수 호출과 호환)
- 인자 개수별 오버로드 (1~5개 + 가변)

**참고:** 현재 Clojure에는 multiple values가 없음. 초기 설계에서는 고려했다가 제거된 것으로 보임.

---

## 커밋 #11
- **Hash:** `3d18eff96403ddee6c3a82307c255dff3500c94a`
- **Date:** 2006-03-28 (커밋 #10 후 19분)
- **Message:** "reformat/comment"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/Symbol.java | +1/-1 |

### 메모
단순 코드 정리. 포맷팅/주석 변경만.

---

## 커밋 #12
- **Hash:** `e63b0c3f98628dce4a9a829466ab67d175dd4414`
- **Date:** 2006-03-28 (커밋 #11 후 1분!)
- **Message:** "first cut of numbers"

### 변경 파일

| 파일 | 변경 |
|------|------|
| src/org/clojure/runtime/Num.java | +164 (신규) |
| src/org/clojure/runtime/DoubleNum.java | +176 (신규) |
| src/org/clojure/runtime/RatioNum.java | +171 (신규) |
| src/org/clojure/runtime/IntegerNum.java | +17 (신규) |
| src/org/clojure/runtime/FloatNum.java | +17 (신규) |
| src/org/clojure/runtime/RealNum.java | +17 (신규) |
| src/org/clojure/runtime/Rational.java | +17 (신규) |

### 메모
**Clojure 숫자 시스템의 탄생!** 579줄의 대형 커밋.

#### 클래스 계층
```
Num (abstract, extends Number)
├── IntegerNum (정수)
│   ├── FixNum (int)
│   └── BigNum (BigInteger)
├── RealNum (실수)
│   ├── FloatNum
│   └── DoubleNum
├── Rational (유리수)
└── RatioNum (분수: numerator/denominator)
```

#### 핵심 기능
```java
// 자동 타입 변환
Num.from(42)           // → FixNum
Num.from(Long.MAX)     // → BigNum (자동 승급!)
Num.from(3.14)         // → DoubleNum

// 다형성 산술 (Double Dispatch)
Num.add(x, y)          // 타입에 맞는 연산 자동 선택
Num.divide(1, 3)       // → RatioNum(1/3) 정확한 유리수!

// Multiple Values 사용!
truncateDivide(tld, n) {
    return RT.setValues(tld, quotient, remainder);  // 몫과 나머지
}
```

#### 설계 포인트
- **정확한 산술**: 분수는 부동소수점 없이 `1/3`으로 유지
- **자동 승급**: int → BigInteger 자동 변환 (오버플로우 방지)
- **Double Dispatch**: `x.add(y)` → `y.addTo(x)` 패턴으로 타입 조합 처리

**Clojure의 "숫자는 정확해야 한다" 철학의 시작!**

---

## 다음 커밋
- **Hash:** `388d2be66c5726698355c46e92c93aec1e369ee0`
